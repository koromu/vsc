#include <iostream>
#include <vector>
#include <math.h>
#define int long long

using namespace std;

int f[110][(1 << 6) + 10][(1 << 6) + 10][25];// f[i][j][k][l][m]// 表示当前是第i列, 当前层状态是j, 上一层状态是k, 上上层状态是l, 使用了m匹马的方案数
int a, b, c;  
int mod = 1e9 + 7;
int cnt(int x)
{
    int ans = 0;
    while(x)
    {
        ans ++;
        x -= (x & -x);
    }
    return ans ;
}


signed main()
{
    cin >> a >> b >> c;
    // 首先一列的情况和上一列的情况和上上列的情况有关系
    // 然后限制我们能使用的马的数量
    // 所以状态需要有这一列的状态, 上一列的状态, 上上列的状态, 当前使用的马的数量, 确定当前列是多少
    // 读入列数n 和 行数m 马的个数k

    // 有前面所有能到达的状态转移而来, 我们需要知道当前层是多少马, 所以需要一个count函数, 或者预处理一个数组, 记录每一个状态的马的数量, 这样的数组需要有1 << 6长度, 还是算了吧

    // 所以f[i][j][k][l][m] = f[i][j][k][l][m] + f[i - 1][], 当前是i-1行, 那么状态就是k, 上一层状态就是l, 上上层不知道,  

    // 但是根据规律, 状态压缩, 如果前两行会影响到当前行, 我们就通过当前行和上一行的状态进行转移, 第i行就会枚举到 i - 1行, i - 1行就会枚举到i - 2行
    // 但是怎么保证i - 2行不会影响到第i行就不知道了
    
    // 好像懂了!
    // 我们会判断当前行和上上行的状态的合法情况, 但是不需要从上上行转移过来, 所以状态转移就是从上一行转移过来
    // 每一行都合法, 那么上一行就是合法的, 那么上一行即使在现在不枚举到上上上行也是合法的
    f[0][0][0][0] = 1;
    for(int i = 1; i <= b ; i ++)
    {
        // 枚举列数, 当前是第i列
        for(int j = 0 ; j <= (1 << a) - 1; j ++)
        {
            // j是当前行
            int count = cnt(j);// 计算出有多少个1的函数
            for(int m = count ; m <= c ; m ++)
                for(int k = 0 ; k <= (1 << a) - 1 ; k ++ )
                {
                // k是枚举上一行
                    for(int l = 0 ; l <= (1 << a) - 1 ; l ++ )
                    {
                        // 枚举上上行的状态
                        // 然后是判断当前行和上两行的状态的合法情况, 然后再统计当前行要新加的马的数量是不是合法的, 我觉得可以先判断马的数量
                        if(!(j & (l << 1)) && !(j & (l >> 1)))// 如果有一个是大于等于1的数的话, 那么就不合法
                        {
                            if(!(l & (k << 2)) && !(l & (k >> 2)))
                            {
                                // 还要判断上一行和上上行的合法情况
                                if(!(j & (k << 2)) && !(j & (k >> 2)))
                                    f[i][j][k][m] = (f[i][j][k][m] + f[i-1][k][l][m - count]) % mod;// 所以
                                // 和上上行的合法情况
                                // 如果都是合法的
                            }
                        }
                    }
                }
        }

    }
    int ans = 0;
    // 最后一层的所有状态和上一层的所有状态, 然后马的数量是K
    // 然后当前行是最后一行
    for(int i = 0 ; i <= (1 << a) - 1 ; i ++)
        for(int j = 0 ; j <= (1 << a) - 1 ; j ++)
        {
            ans = (ans + f[b][i][j][c]) % mod;
        }

    cout << ans << endl;

    return 0;
}
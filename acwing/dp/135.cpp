#include <iostream>
#include <climits>
using namespace std;

const int N = 300010;
int n, m;
int w[N];

int q[N];//每个点入队一次

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> w[i];
        w[i] += w[i - 1];
    }
    int hh = 0, tt = 0;
    // q[tt] = 1;//先插入第一个元素
    // int ans = 0;
    int ans = INT_MIN;

    // 我们要这个区间的和最大, 就是说这个区间中前面的前缀和最小, 后面的前缀和最大
    // 我们要看所有长度不超过m的区间, 所以遍历右端点, 然后看这个右端点对应的最大值是多少

    // 遍历右端点, 然后维护一个区间长度不超过m的最小值, 所以是用单调队列维护
    // 一个单调队列, 有头节点和尾节点, 每次处理一个右端点, 右端点一定会入列, 在入列之前为了维护最小值, 所以如果这个右端点比当前的尾节点的值小, 那么就弹出这个尾节点, 知道队列为空, 或者当前的尾节点的值比当前的右端点小, 那么可以把这个元素插入到队尾了
    // 但是也要注意, 插入这个节点之前, 我们先要判断队头是不是还能在区间里面
    for (int i = 1 ; i <= n ; i ++)
    {
        while(hh <= tt && i - q[tt] >= m - 1 ) hh ++;//当前区间只能有m-1个下标, 因为准备插入这个i了, 而合法的情况就是i - q[hh] <= m - 2,也就是i - q[hh] < m - 1, 所以不合法的就是 i - q[hh] >= m - 1;
        //队头的元素合法了, 然后可以取出队头元素, 更行一下当前这个右端点的答案
        ans = max(ans, w[i] - w[q[hh]]);
        //然后插入当前元素
        while(hh <= tt && w[q[tt]] >= w[i]) tt --; //如果队尾元数大于当前元素, 那么就弹出尾节点
        q[++tt] = i;
    }
    cout << ans << endl;
    return 0;
}
#include <iostream>

using namespace std;

const int N = 50010;
int n, t;
int w[N]; // 记录每一题的代价
int q[N]; // 单调队列优化
int f[N];
bool check(int m)
{
    f[0] = 0;
    int hh = 0, tt = 0; // 第一个元素
    for (int i = 1; i <= n; i++)
    { // 当前第i个要不要插入呢?不用
        // 那么用i来算边界的话, 那么i前面可以有m + 1个元素, 包括i的话就是m + 2个元素, 那么就是i - q[hh] >= m + 3
        if (hh <= tt && i - q[hh] >= m + 2)
            hh++; //?
        f[i] = f[q[hh]] + w[i];
        while (hh <= tt && f[q[tt]] >= f[i])
            tt--;
        q[++tt] = i;
    }
    // 看看是最后__个中是否有一个花费时间小于t的, 如果有, 说明还可以加时间
    // 那么是多少个呢, 不能有m个空题, 那么就是最后m个中最少有一个
    for (int i = n; i >= n - m; i--)
        if (f[i] < t)
            return true;

    return false;
}
int main()
{
    cin >> n >> t;
    for (int i = 1; i <= n; i++)
        cin >> w[i];

    // 其他题目都是一个不能超过的长度, 问方案数, 这题问的是不能超过的长度是什么
    // 知道一个总时间, 问在总时间内合法的最长的空题段是多少, 总时间肯定是要拉满的
    // 一个空题长度肯定对应一个最少花费的时间, 所以可以枚举空题长度, 算到最少花费时间等于t时的空题长度, 就是我们要求的
    // 枚举使用二分查找, 然后判断这个空题长度对应的时间是多少, 如果这个空题长度对应的时间比预计花费的时间少, 说明空多了, 如果对应时间花多, 那么可以增加空题长度
    // 所以先枚举空题长度m, 然后计算最长m + 1个题目中至少写了一题的最少代价, 所以是一个m + 1的区间中找到最小的那个代价
    // 所以可以维护一个首元素最小单调队列, 顺时针的, 所以枚举右端点, f[i]表示选第i个题目并且前m + 1个区间中选最小的那个代价的最小代价
    int l = 0, r = n;
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid))
        { // 如果时间多了, 那么就增加空题长度, 也就是答案在右边
            r = mid - 1;
        }
        else
            l = mid;
    }

    cout << r << endl;

    return 0;
}

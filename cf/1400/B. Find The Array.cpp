#include <iostream>
#include <algorithm>

#define int long long
using namespace std;

const int N = 55;
int a[N];
void solve()
{   
    // 非常容易的发现1是万能的，能整除合法的数，所以可以用1填补到一些位置上
    // 其中还有一个条件就是每一位的方差的两倍之和要小于a数组的总和S
    // 非常巧妙地想到了可以对a数组直接进行操作，a数组中相邻的位置不一定是能够整除的
    // 所以对a数组进行替换1就行了，虽然这样就会产生很大的方差，但是发现我们只产生一个位置的方差，然后另一个位置的方差是0
    // 所以我们的这两个位置方差和其实就是一个被改成1的方差的两倍
    // 极端情况如果每两个位置都这样的话，那我们为了让每一个位置不超过原本的数，我们只能改这两个位置中数字小的那个数字，这样总和只会减小
    // 但是发现如果改了一个位置，那么这位置的左右两侧一定不能改，因为每两个位置只能改一个
    // 所以我们考虑间隔一个选一个，全部改掉，为了满足方差和
    // 我们直接计算从第一个开始改和从第二个开始改，步长都是2，这两组数的和
    // 实际就是奇数位和偶数位
    // 改和小的那个
    int n; cin >> n;
    int suml = 0, sumr = 0;
    // 如果总共有奇数个
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> a[i];
        if(i % 2) suml += a[i];
            // 如果是2的倍数
        else sumr += a[i];
    }

    if(suml > sumr)// 如果奇数大于偶数， 那么改偶数
        for(int i = 1 ; i <= n ; i ++)
        {
            if(i % 2 == 0) cout << 1 << " ";
            else cout << a[i] << " ";
        }
    else 
        for(int i = 1 ; i <= n ; i ++)
        {
            if(i % 2 == 0) cout << a[i] << " ";
            else cout << 1 << " ";
        }
    cout << endl;
    return ;
    // 为什么不用考虑原数组的奇偶性呢
    // 证明见下图
}


signed main()
{
    int _; cin >> _;
    while(_--) solve();
    return 0;
}